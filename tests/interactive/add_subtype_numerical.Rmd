

```{r}

load_all()
library(tidyverse)
#Survey name
survey_name <- "NRFSP Food Safety Manager Validation Survey"
survey_nickname <- "NRFSP FSM"

#Find survey
surveys <- browse_surveys(200)

#Get ID
survey_id <- surveys %>% 
  filter(title == survey_name) %>% 
  pull(id)

#Collect, parse, and clean
survey_df <-   
  fetch_survey_obj(as.numeric(survey_id))

results <- survey_df %>%
  parse_survey(col_names = "name")

surv_obj <- survey_df

```

```{r}
#source debug_helpers.R
family_data <- summarize_survey_families(surv_obj)
family_data_types <- analyze_survey_families(surv_obj)

```

```{r}
family_data_types %>% 
  filter(family == "single_choice" & subtype == "menu")


family_data_types %>% 
  filter(family == "single_choice" & subtype == "vertical")

family_data_types %>% 
  filter(family == "multiple_choice" & subtype == "vertical")

family_data_types %>% 
  filter(family == "single_choice" & subtype == "single")
family_data_types %>% 
  filter(family == "matrix" & subtype == "single")

family_data_types %>% 
  filter(family == "open_ended" & subtype == "essay")
```
```{r}

items <- list(open_numeric = "228210658",
     open_text = "225780190",
     matrix_single = "225780193" ,
     single_choice_vertical = "225780212",
     single_choice_menu = "228211697"
)


respondents <- get_responses(surv_obj$id, oauth_token = get_token())
return_question <- list()

for(i in 1:length(items)){
  
  item_id <-  items[[i]]
  item_category <-  names(items[i])

for(r in 1:length(respondents)){
  response <- respondents[[r]]
  pages <- respondents[[r]]$pages
  record <- list()
    for (p in 1:length(pages)) {
      page <- pages[[p]]
      if (length(page$questions) == 0) {
        next
      }
      for (q in 1:length(page$questions)) {
        question <- page$questions[[q]]
        question_id <- question$id
        if(question_id == item_id){
          return_question[[item_category]] <- question
          break
        }else{
          next
        }
      }
    }
}

}



question_id <- return_question$open_numeric[[1]]
question <- return_question$open_numeric
#question <- return_question

#NEW

#Added subtype nuerical to open_ended
process_open_ended <- function(surv_obj, question) {
  question_id = question$id
  col_id = question_id
  family = surv_obj$families[[question_id]]
  subtype = surv_obj$subtypes[[question_id]]
  
  question_text = surv_obj$questions[[question_id]]
  
  if(subtype == "numerical"){
    out_named <- list()
    out_id <- list()
    
    for(answer in question$answers){
    #answer <- question$answers[[1]]
    col_id = paste0(question_id, "_", answer$row_id)
    question_text <- paste0(question_text, " - ", surv_obj$answers[[answer$row_id]])
    answer_text = answer$text
    
    out_id[[col_id]] <- answer_text
    out_named[[question_text]] <- answer_text
    
    return(list(name = out_named, id = out_id))
    }
    
  }else{
    answer_text = question$answers[[1]]$text
    
    return(list(name = make_output_named(question_text=question_text,
                                         answer_text=answer_text),
                id = make_output_id(col_id=col_id, 
                                    answer_text=answer_text)))
  }
  
}




# 
# 
# process_single_choice(surv_obj, return_question$single_choice_vertical)
# 
# outmatrix <- process_matrix(surv_obj, return_question$matrix_single)
# 
# process_open_ended(surv_obj, return_question$open_text)
# 
# out <- process_open_ended(surv_obj, return_question$open_text)
# 
# out2 <- process_open_ended(surv_obj, return_question$open_numeric)




results %>% select(starts_with("Please"))
```



```{r}


# If you find a question that looks like Multiple Textboxes, examine it directly
if (nrow(textbox_questions) > 0) {
  # Take the first match as an example
  example_id <- "228210658"
  
  # Find the question in the survey object
  for (page in surv_obj$pages) {
    for (question in page$questions) {
      if (question$id == example_id) {
        # Print full question details for analysis
        print(question)
        break
      }
    }
  }
}


```


```{r}



```
```{r}
#' Take a survey object and parse it into a tidy dataframe.
#'
#' @param surv_obj A survey, the result of a call to \code{fetch_survey_obj}.
#' @param oauth_token Your OAuth 2.0 token. By default, retrieved from
#'  \code{get_token()}.
#' @param col_names Set column names either to names ("name") or IDs ("id", default). Depending on question types, column names will be formatted as one of the following where each `{}` element is either an ID or a name:
#' \itemize{
#'   \item '\{question heading\}'
#'   \item '\{question heading\} - Other'
#'   \item '\{question heading\} - \{matrix row\}'
#'   \item '\{question heading\} - \{matrix row\} - \{matrix column\}'
#' }
#' @param col_fill For the columns extracted from a multi-select question, how to fill in values. Choices are either TRUE or "name" denoting the name of each question choice. Default is TRUE.
#' @param ... Additional arguments to pass on to \code{get_responses}.  See the documentation
#' \code{?get_responses} where these arguments are listed.
#' @return A data.frame (technically a \code{tibble}) with clean responses, one line per respondent.
#' @importFrom rlang .data
#' @export
parse_survey <- function(surv_obj, 
                         oauth_token = get_token(),
                         col_names = "name",
                         col_fill = TRUE,
                         ...
) {
  . <- NULL
  if (surv_obj$response_count == 0) {
    warning("No responses were returned for this survey.  Has anyone responded yet?")
    return(data.frame(survey_id = as.numeric(surv_obj$id)))
  }
  if (!(col_names %in% c("id","name"))) {
    stop("Must pass either 'id' or 'name' to col_names.")
  }

  if (!(col_fill %in% c(TRUE,"name"))) {
    stop("Must pass either TRUE or 'name' to col_fill.")
  }
  
  message("Getting responses 🎣")
  
  time_start <- Sys.time()
  respondents <- get_responses(surv_obj$id, oauth_token = oauth_token)
  time_end <- Sys.time()
  time_taken <- time_end - time_start
  print(time_taken)
  
  message("Parsing responses ⛏")
  
  surv_obj$col_fill <- col_fill
  
  labels <- list()
  recordsList <- pbapply::pblapply(1:length(respondents), function(r) {
    response <- respondents[[r]]
    pages <- respondents[[r]]$pages
    record <- list()
    for (p in 1:length(pages)) {
      page <- pages[[p]]
      if (length(page$questions) == 0) {
        next
      }
      for (q in 1:length(page$questions)) {
        question <- page$questions[[q]]
        question_id <- question$id
        # if (startsWith(question_id, "86524344")) stop("")
        family <- surv_obj$families[[question_id]]
        if (family == "matrix") {
          out <- process_matrix(surv_obj, question)
        }
        if (family == "multiple_choice") {
          out <- process_multiple_choice(surv_obj, question)
        }
        if (family == "single_choice") {
          out <- process_single_choice(surv_obj, question)
        }
        if (family == "open_ended") {
          out <- process_open_ended(surv_obj, question)
        }
        if (family == "demographic") {
          out <- process_open_ended(surv_obj, question)
        }
        if (family == "datetime") {
          out <- process_datetime(surv_obj, question)
        }
        if (col_names == "id") {
          col <- out$id
          labels_new <- as.list(names(out$name))
          # names(labels_new) <- names(out$id) ## labels will always be question text
          names(labels_new) <- names(out$name)
        } else {
          col <- out$name
          labels_new <- as.list(names(out$id))
          names(labels_new) <- names(out$name)
        }
        ## checking for this explicitly since it unexpectedly 
        ## happens sometimes on the backend (see issue #21)
        dup_qs <- (names(labels_new) %in% names(record))
        if (any(dup_qs)) {
          labels_new <- labels_new[!dup_qs]
          col <- col[!dup_qs]
        } 
        if (length(col) > 0 & length(labels_new) > 0) {
          labels <<- modifyList(labels, labels_new)
          record <- append(record, col)
        }
      }
    }
    record$collector_id <- as.numeric(response$collector_id)
    record$collection_mode <- response$collection_mode
    record$response_id <- as.numeric(response$id)
    record$response_status <- response$response_status
    record$date_created <- response$date_created
    record$date_modified <- response$date_modified  
    record$first_name <- response$first_name
    record$last_name <- response$last_name
    record$email_address <- response$email_address
    record$ip_address <- response$ip_address
    
    return(dplyr::bind_cols(record))
  })
  
  message("Merging responses 🤝")
  
  records <- dplyr::bind_rows(recordsList)
  records$survey_id <- as.numeric(surv_obj$id)
  

  for (q in rev(names(surv_obj$questions))) {
    if (col_names == "id") {
      cols <- colnames(records)[grepl(q, colnames(records))]
    } else {
      cols <- names(labels[startsWith(unlist(labels), q)])
    }
    if (length(cols) > 0) {
      records <- dplyr::relocate(records, cols)

    }
    if (length(cols) > 0) {
      records <- dplyr::relocate(records, cols)
    }    
  }
  
  records <- dplyr::relocate(records, c("collector_id",
                                        "collection_mode",
                                        "survey_id",
                                        "response_id",
                                        "response_status",
                                        "date_created",
                                        "date_modified",
                                        "first_name",
                                        "last_name",
                                        "email_address",
                                        "ip_address"))
  

  colnames(records) <- gsub("  ", " ", colnames(records))
  names(labels) <- gsub("  "," ", names(labels))
  
  message("Levelling columns 🗂")

  for (level.var in names(surv_obj$choices)) {
    if (col_names == "id") {
      col.levels <- unique(surv_obj$choices[[level.var]])
      col.vars <- colnames(records)[grepl(level.var, colnames(records))]
    } else {
      col.levels <- unique(surv_obj$choices[[level.var]])
      col.vars <- names(labels[startsWith(unlist(labels), level.var)])
    }
    for (col.var in col.vars) {
      if (all(unique(records[[col.var]]) %in% c(NA, col.levels)) &
          !(all(unique(records[[col.var]]) %in% c(NA, T,F)))) {
        records[[col.var]] <- factor(records[[col.var]], levels = col.levels)
        base::levels(records[[col.var]]) <- col.levels
      }
    }
  }
  
  message("Labelling columns 🗂")
  
  labels$collector_id <- "Collector ID"
  labels$collection_mode <- "Collector mode"
  labels$survey_id <- "Survey ID"
  labels$response_id <- "Response ID"
  labels$response_status <- "Response status"
  labels$date_created <- "Date response created"
  labels$date_modified <- "Date response modified"
  labels$first_name <- "Respondent's first name"
  labels$last_name <- "Respondent's last name"
  labels$email_address <- "Respondent's email address"
  labels$ip_address <- "Respondent's IP address"
  
  if (col_names == "id") {
    labels <- labels[names(labels) %in% colnames(records)]
    # # Convert list to named character vector
    # labels <- unlist(labels)
    # records <- records %>%
    #   labelled::set_variable_labels(.labels = labels)
    
    labels <- labels[names(labels) %in% colnames(records)]
    # Use direct variable label assignment
     labelled::var_label(records) <- labels
  }
  
  if (sample(c(1,2,3,4,5),1)==1) {
    message("\nDONE 🐵\n") 
  } else if (sample(c(1,2,3,4,5),1)==2) {
    message("\nDONE 🙈\n") 
  } else if (sample(c(1,2,3,4,5),1)==3) { 
    message("\nDONE 🙉\n") 
  } else if (sample(c(1,2,3,4,5),1)==4) { 
    message("\nDONE 🙊\n") 
  } else { 
    message("\nDONE 🐒\n")
  }
  
  message(sprintf("%d rows x %d columns", nrow(records), ncol(records)))
  return(records)
}


```

